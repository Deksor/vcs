<!DOCTYPE html>

<html>
    <head>
        <meta name="viewport" content="width=device-width">
        <meta http-equiv="content-type" content="text/html; charset=UTF-8">

        <link rel="stylesheet" href="https://www.tarpeeksihyvaesoft.com/assets/font-awesome-5-15-4/css/all.min.css">
        <script defer src="https://www.tarpeeksihyvaesoft.com/assets/font-awesome-5-15-4/attribution.js"></script>
        <script defer src="https://www.tarpeeksihyvaesoft.com/dokki/distributable/dokki.js"></script>

        <script type="module">
            import {keyboardKey, keyCombo} from "./js/dokki-components/key-combo.js";
            import {menuPath} from "./js/dokki-components/menu-path.js";
            window.dokkiUserComponents = [menuPath, keyboardKey, keyCombo];
        </script>

        <style>
            .dokki-topic .menu-path,
            .dokki-topic .key-combo
            {
                padding: 1px 6px;
                border-radius: 3px;
                margin: 2px 0;
                white-space: nowrap;
                display: inline-flex;
                align-items: center;
                border: 1px solid;
                box-shadow: -1px 1px 0 #505050;
                margin-left: 1px;
                transform: translateY(-1px);
            }

            .dokki-topic strong
            {
                font-weight: var(--dokkiCSS-bold-text-weight);
            }

            .dokki-topic em
            {
                font-style: inherit;
                background-color: var(--vcs-highlight-color);
                font-weight: var(--dokkiCSS-bold-text-weight);
            }

            .dokki-topic td > .dokkiCSS-embedded
            {
                margin: 16px 0;
            }

            .dokki-topic td > .dokkiCSS-embedded:last-child
            {
                margin-bottom: 0;
            }
            
            .dokki-topic td > .key-combo
            {
                margin: 0;
            }

            .dokki-topic .keyboard-key:not(:last-child)::after
            {
                content: "+";
                margin: 0 0.125em;
            }

            .dokki-topic table.wrap-last-td td:last-child
            {
                white-space: normal;
            }

            .dokki-table td.with-inline-table
            {
                padding: 0 !important;

                /* Force the <td> to not expand to fit the width of the inline table, so that the
                * inline table - and not the parent table - gets the horizontal scroll bar.*/
                max-width: 0;
            }

            .dokki-table td.with-inline-table > .dokki-table
            {
                margin: 0;
                border: none;
                border-radius: 0;
                background-color: inherit;
            }

            .dokki-table td.with-inline-table > .dokki-table > header
            {
                padding: 8px;
                line-height: var(--dokkiCSS-content-line-height);
            }

            .dokki-table td.with-inline-table > .dokki-table > header > .dokki0-expansion-indicator
            {
                margin-right: 0.75ch;
            }

            .dokki-table td.with-inline-table > .dokki-table > header > .caption > .icon
            {
                display: none;
            }

            .dokki-table td.with-inline-table > .dokki-table > header > .title
            {
                display: none;
            }

            .dokki-table ul
            {
                padding-inline-start: 1.25em !important;
            }

            .dokki-table ul li
            {
                line-height: 1;
            }
        </style>
    </head>
<body>
            <template id="dokki-document">
                <dokki-toolbar>
                    <template #caption>
                        
        VCS 2.5.0 • User's manual
    
                    </template>
                    
                </dokki-toolbar>
                <dokki-topics>
                    <dokki-topic title='System requirements'>
<dokki-table headerless>
    <template #table>
        <tr>
            <th>OS</th>
            <td class="with-inline-table">
                <dokki-table>
                    <template #table>
                        <tr>
                            <th>Platform</th>
                            <th>Required version</th>
                        </tr>
                        <tr>
                            <td>Windows</td>
                            <td>XP or later</td>
                        </tr>
                        <tr>
                            <td>Linux</td>
                            <td>Kernel 5</td>
                        </tr>
                    </template>
                </dokki-table>
            </td>
        </tr>
        <tr>
            <th>CPU</th>
            <td class="with-inline-table">
                <dokki-table>
                    <template #table>
                        <tr>
                            <th>Capture resolution</th>
                            <th>Required performance level<sup>*</sup></th>
                        </tr>
                        <tr>
                            <td>VGA</td>
                            <td>Intel Sandy Bridge</td>
                        </tr>
                        <tr>
                            <td>1080p, 30 FPS</td>
                            <td>Intel Haswell</td>
                        </tr>
                        <tr>
                            <td>1080p, 60 FPS</td>
                            <td>Intel Coffee Lake</td>
                        </tr>
                        <tr>
                            <td colspan="2">
                                <sup>*</sup>Estimated.
                            </td>
                        </tr>
                    </template>
                </dokki-table>
            </td>
        </tr>
        <tr>
            <th>GPU</th>
            <td>
                For hardware rendering (optional), an OpenGL 1.2-compatible video card
            </td>
        </tr>
        <tr>
            <th>RAM</th>
            <td>1 GB</td>
        </tr>
        <tr>
            <th>Other</th>
            <td>
                <ul>
                    <li>The Datapath capture card driver must be installed</li>
                    <li>On Linux, the legacy OpenCV 3.2.0 library must be installed</li>
                </ul>
            </td>
        </tr>
    </template>
</dokki-table>
</dokki-topic><dokki-topic title='Getting started'>
<p>Assuming you've installed the driver for your capture device, as well as unpacked the binary distribution of VCS (linked to, above) into a folder, getting VCS going is simply a matter of running its <em>vcs.exe</em> executable.</p>
<p>When you run the executable, two windows will open: a console window, in which notifications about VCS's status will appear during operation; and the output window, in which captured frames are displayed.</p>
<dokki-tip>
    You can use VCS's <a href="#command-line-options">command-line options</a> to automate
    start-up tasks.
</dokki-tip>
<p>If this is your first time running VCS, the first thing you may want to do is adjust the capture video parameters (phase, position, colors, etc.). They can be set up via the <a href="#video-presets-dialog">video presets</a> dialog.</p>
</dokki-topic><dokki-topic title='Output window'>
<p>The central point of the VCS user interface is the output window, where captured frames are displayed as they arrive from the capture device and having undergone any of VCS's filtering and scaling.</p>
<dokki-image src=https://github.com/leikareipa/vcs/raw/master/images/screenshots/v2.3.0/output-window.png width=642 height=508     ><template #caption>A screenshot of the output window</template>
                    </dokki-image>
<dokki-subtopic title='Features'>
<h3>Magnifying glass</h3>
<p>If you press the middle mouse button over the output window, a magnifying glass will pop up, showing an elarged view of the area around the cursor.</p>
<dokki-tip>
    The magnifying glass feature isn't available while using the OpenGL renderer.
</dokki-tip>
<h3>Dragging</h3>
<p>You can drag the output window by left-clicking and holding anywhere on the window.</p>
<h3>Borderless mode</h3>
<p>You can double-click inside the output window to toggle borderless mode on/off. The <key-combo>F1</key-combo> key will also toggle this mode.</p>
<h3>Resizing</h3>
<p>The output window – along with the frames it's displaying – can be resized via the <a href="#output-resolution-dialog">Output resolution</a> dialog. Spinning the mouse scroll wheel over the output window will also adjust the output size.</p>
<h3>Fullscreen mode</h3>
<p>Although you can emulate a fullscreen mode by turning off the output window's border and then scaling the window to the size of the the display area, there's also a true fullscreen mode available. You can toggle it on/off with the <key-combo>F11</key-combo> key.</p>
<dokki-warning>
    For the fullscreen mode to work best, you may first need to manually resize the output window to match the resolution of your screen.
</dokki-warning>
</dokki-subtopic><dokki-subtopic title='Title bar'>
<p>The output window's title bar shows information about VCS's current operating state – for example, the input and output resolution.</p>
<dokki-image src=./img/title-bar.png width=479 height=25     ><template #caption>A sample of the output window's title bar on Linux</template>
                    </dokki-image>
<p>The title bar may contain some or all of the following elements, from left to right:</p>
<dokki-table headerless>
    <template #table>
        <tr>
            <th>Element</th>
            <th>Desription</th>
        </tr>
        <tr>
            <td>{!}</td>
            <td>
                The frame drop indicator. Shown when VCS is having to drop captured frames due to insufficient performance (e.g. the CPU not being fast enough for the current capture settings).
            </td>
        </tr>
        <tr>
            <td>VCS</td>
            <td>
                The program's name.
            </td>
        </tr>
        <tr>
            <td>- RFOA -</td>
            <td class="with-inline-table">
                <dokki-table>
                    <template #table>
                        <tr>
                            <th>Element</th>
                            <th>Explanation</th>
                        </tr>
                        <tr>
                            <td>R</td>
                            <td>
                                Shown when video recording is active (see <a href="#video-record-dialog">Video recorder dialog</a>)
                            </td>
                        </tr>
                        <tr>
                            <td>F</td>
                            <td>
                                Shown when the filter graph is active (see <a href="#filter-graph-dialog">Filter graph dialog</a>)
                            </td>
                        </tr>
                        <tr>
                            <td>O</td>
                            <td>
                                Shown when the overlay is active (see <a href="#overlay-dialog">Overlay dialog</a>)
                            </td>
                        </tr>
                        <tr>
                            <td>A</td>
                            <td>
                                Shown when anti-tearing is active (see <a href="#anti-tear-dialog">Anti-tear dialog</a>)
                            </td>
                        </tr>
                    </template>
                </dokki-table>
            </td>
        </tr>
        <tr>
            <td>░ &times; ░ (░ Hz)</td>
            <td>
                The current capture resolution and its refresh rate.
            </td>
        </tr>
        <tr>
            <td>scaled to ░ &times; ░ (░ FPS)</td>
            <td>
                The current output resolution and the rate at which the output is being updated.
            </td>
        </tr>
    </template>
</dokki-table>
<p>Under special circumstances, the title bar may also show one of these messages:</p>
<dokki-table headerless>
    <template #table>
        <tr>
            <th>Message</th>
            <th>Reason</th>
        </tr>
        <tr>
            <td>No signal</td>
            <td>
                The capture device doesn't appear to be receiving a signal.
            </td>
        </tr>
        <tr>
            <td>Signal out of range</td>
            <td>
                Either VCS or the capture device is unable to process the current video mode because the mode exceeds operating parameters (e.g. too high of a resolution).
            </td>
        </tr>
        <tr>
            <td>Invalid capture channel</td>
            <td>
                The requested input channel on the capture device is unavailable for use.
            </td>
        </tr>
    </template>
</dokki-table>
</dokki-subtopic><dokki-subtopic title='Context menu'>
<p>Right-clicking inside the output window will bring up its context menu, which gives you access to the various controls and dialogs of VCS.</p>
<h3>Eye dropper</h3>
<p>The eye dropper is a special non-interactible element of the context menu. It shows the RGB color values of the pixel over which the context menu was opened.</p>
<h3>Input</h3>
<p>The input menu lets you customize various operational parameters of the capture device. The menu provides the following options:</p>
<dokki-table headerless>
    <template #caption>
        The input menu's sub-menus
    </template>
    <template #table>
        <tr>
            <th>Option</th>
            <th>Explanation</th>
        </tr>
        <tr>
            <td>Channel</td>
            <td>
                Set the capture device's active input channel.
            </td>
        </tr>
        <tr>
            <td>Color depth</td>
            <td>
                Set the color depth in which the capture device outputs frames. In other words, the device is expected to convert frame data into this format prior to transferring them via the system bus to VCS. Prior to display, VCS will convert the data into the color depth of the <a href="#output-window">output window</a>.
            </td>
        </tr>
        <tr>
            <td>De-interlacing</td>
            <td>
                Set the hardware-side de-interlacing mode for interlaced signals. This setting is expected to have no effect on non-interlaced signals.
            </td>
        </tr>
    </template>
</dokki-table>
<h3>Output</h3>
<p>The output menu lets you customize the way in which VCS processes captured frames prior to display in the <a href="#output-window">output window</a>. The menu provides the following options:</p>
<dokki-table headerless>
    <template #caption>
        The output menu's sub-menus
    </template>
    <template #table>
        <tr>
            <th>Option</th>
            <th>Explanation</th>
        </tr>
        <tr>
            <td>Screenshot</td>
            <td>
                Save the current output image into an image file.
            </td>
        </tr>
        <tr>
            <td>Aspect ratio</td>
            <td class="with-inline-table">
                <dokki-table>
                    <template #table>
                        <tr>
                            <th>Sub-option</th>
                            <th>Explanation</th>
                        </tr>
                        <tr>
                            <td>Native</td>
                            <td>
                                Don't force captured frames into a specific aspect ratio.
                            </td>
                        </tr>
                        <tr>
                            <td>Traditional 4:3</td>
                            <td>
                                Force captured frames into a 4:3 aspect ratio for such input resolutions that historically might have been meant to be displayed as such; for example, 720 &times; 400, 640 &times; 400, and 320 &times; 200.
                            </td>
                        </tr>
                        <tr>
                            <td>Always 4:3</td>
                            <td>
                                Force all captured frames into a 4:3 aspect ratio.
                            </td>
                        </tr>
                    </template>
                </dokki-table>
            </td>
        </tr>
        <tr>
            <td>Upscaler</td>
            <td>
                Set the scaler to be used when frames are upscaled to fit the output window.
            </td>
        </tr>
        <tr>
            <td>Downscaler</td>
            <td>
                Set the scaler to be used when frames are downscaled to fit the output window.
            </td>
        </tr>
    </template>
</dokki-table>
<h3>Window</h3>
<p>The window menu lets you customize various properties of the <a href="#output-window">output window</a>. The menu provides the following options:</p>
<dokki-table headerless>
    <template #caption>
        The window menu's sub-menus
    </template>
    <template #table>
        <tr>
            <th>Option</th>
            <th>Explanation</th>
        </tr>
        <tr>
            <td>Renderer</td>
            <td class="with-inline-table">
                <dokki-table>
                    <template #table>
                        <tr>
                            <th>Sub-option</th>
                            <th>Explanation</th>
                        </tr>
                        <tr>
                            <td>Software</td>
                            <td>
                                Draw the window using software rendering. Performs well and supports the most features, but may not allow variable refresh rate output.
                            </td>
                        </tr>
                        <tr>
                            <td>OpenGL</td>
                            <td>
                                <p>
                                    Draw the window using OpenGL. Allows variable refresh rate output (if supported by your hardware), but is incompatible with Windows XP and the magnifying glass feature.
                                </p>
                            </td>
                        </tr>
                    </template>
                </dokki-table>
            </td>
        </tr>
        <tr>
            <td>Border</td>
            <td>
                A hint to the operating system on whether to decorate the output window with the system's window border and title bar. When the window is in borderless mode, the operating system is also asked to position it on top of other desktop elements. You can achieve a windowed fullscreen mode by disabling the window border and setting the <a href="#output-resolution-dialog">Output resolution</a> to match your desktop resolution (see also the <em>Top left</em> menu option).
            </td>
        </tr>
        <tr>
            <td>Fullscreen</td>
            <td>
                Place the output window into fullscreen mode. For best results, you should first scale the window to the resolution of your screen before entering fullscreen mode. Not fully supported on some distributions of Linux.
            </td>
        </tr>
        <tr>
            <td>Center</td>
            <td>
                Snap the output window to the middle of the screen.
            </td>
        </tr>
        <tr>
            <td>Top left</td>
            <td>
                Snap the output window to the top left corner of the screen.
            </td>
        </tr>
        <tr>
            <td>Set title...</td>
            <td>
                Give the output window a custom title. All of VCS's normal title bar information - except the frame drop indicator - will be replaced with the text you set. Setting an empty string will restore VCS's default title bar.
            </td>
        </tr>
    </template>
</dokki-table>
</dokki-subtopic></dokki-topic><dokki-topic title='Video presets dialog'>
<p>This dialog can be accessed with <key-combo>Ctrl + V</key-combo> or <menu-path>Context &gt; Input &gt; Dialogs &gt; Video presets...</menu-path>.</p>
<dokki-image src=https://github.com/leikareipa/vcs/raw/master/images/screenshots/v2.4.0/video-presets-dialog.png width=513 height=656     ><template #caption>A screenshot of the video presets dialog</template>
                    </dokki-image>
<p>The video presets dialog lets you to modify the capture devices's video signal parameters.</p>
<p>A given video preset's parameters will be applied when all of its &quot;Activates with&quot; conditions are met. For instance, if you've defined a preset's activation resolution as 800 × 600 and have disabled the other activating conditions, the preset's parameters will be applied when the capture video mode is 800 × 600.</p>
<p>To add or delete a preset, click the + or - buttons next to the preset selector at the top of the dialog. Clicking the + button while holding the Alt key will create a new preset with the current preset's settings.</p>
<p>If you want your changes to the video presets to persist after you exit VCS, remember to save them first! This can be done via <menu-path>File &gt; Save as…</menu-path>. Saved settings can be restored via <menu-path>File &gt; Open…</menu-path>. Any saved settings that're open when VCS exits will be reloaded automatically when you run VCS again.</p>
</dokki-topic><dokki-topic title='Alias resolutions dialog'>
<p>This dialog can be accessed with <menu-path>Context &gt; Input &gt; Dialogs &gt; Aliases...</menu-path>.</p>
<p>With the alias resolutions dialog, you can instruct VCS to automatically override certain capture resolutions.</p>
<p>For instance, if you find that your capture device is displaying 640 × 400 as 512 × 488 (or something to that effect), you can define 640 × 400 as an alias of 512 × 488. Whenever the capture device reports a new video mode of 512 × 488, VCS will tell the device to use 640 × 400, instead.</p>
</dokki-topic><dokki-topic title='Video recorder dialog'>
<p>This dialog can be accessed with <key-combo>Ctrl + R</key-combo> or <menu-path>Context &gt; Output &gt; Dialogs &gt; Video recorder...</menu-path>.</p>
<dokki-warning>
    On Linux, the video encoder's quality settings can't be modified through VCS &ndash; you'd need to re-compile OpenCV with your desired encoder settings, instead.
</dokki-warning>
<p>The video recorder gives you the option to stream captured frames into a video file.</p>
<p>To use the video recorder in Windows, you'll need to install the 32-bit version of the <a href="https://sourceforge.net/projects/x264vfw/files/x264vfw/44_2851bm_44825/">x264vfw</a> codec and run its configurator at least once, so that its settings are added into the Windows registry for VCS to find.</p>
<p>The recorder will write frames as they appear in the <a href="#output-window">output window</a> into a video file, with the following caveats:</p>
<ul>
<li>Audio won't be recorded.</li>
<li>Frames will be inserted into the video at the rate of capture; the recorder doesn't try to maintain any particular frame rate (e.g. by duplicating or dropping frames). For example, if your capture source is 57.5 Hz, one minute of video will have 57.5 * 60 frames, and if that video is played back at 60 FPS, it will appear slightly sped up.</li>
<li>If VCS drops any frames during recording (e.g. due to insufficient system performance), the video's playback will be non-linear. So if you're recording a separate audio file and are planning to sync it with the video, you want there to be no frames dropped while recording the video.</li>
<li>The video will be recorded in the H.264 format using an x264 codec.</li>
<li>The video resolution will be that of the current output size (see the <a href="#output-resolution-dialog">Output resolution</a> dialog).</li>
<li>The output size can't be changed while recording; all frames will be scaled automatically to fit the current size.</li>
<li>The <a href="#overlay-dialog">overlay</a> won't be recorded.</li>
<li>Encoder parameters influencing image quality (e.g. CRF) can't be customized in the Linux version of VCS. This is a limitation of OpenCV. You can, however, modify and recompile the OpenCV code with higher-quality default options (see e.g. <a href="https://www.researchgate.net/post/Is_it_possible_to_set_the_lossfree_option_for_the_X264_codec_in_OpenCV">here</a>).</li>
</ul>
<dokki-subtopic title='Settings explained'>
<dokki-table headerless>
    <template #table>
        <tr>
            <th>Setting<sup>*</sup></th>
            <th>Description</th>
        </tr>
        <tr>
            <td>Nominal FPS</td>
            <td>
                The video's suggested playback rate. This setting doesn't affect the recording rate, only the rate at which the video might be played back by your video player. The actual recording FPS will be determined by the capture source's refresh rate.
            </td>
        </tr>
        <tr>
            <td>Video container</td>
            <td>
                The file format used for storing the video on disk.
            </td>
        </tr>
        <tr>
            <td>Video codec</td>
            <td>
                The codec used for encoding the video. Currently, only <em>x264</em> is supported.
            </td>
        </tr>
        <tr>
            <td>Arguments</td>
            <td>
                You can enter any additional command-line arguments for the video codec.
            </td>
        </tr>
        <tr>
            <td colspan="2">
                <sup>*</sup>Only some of the available settings are included in this list; others depend on the choice of video codec and are as per standard for that codec (e.g. CRF for x264).
            </td>
        </tr>
    </template>
</dokki-table>
</dokki-subtopic><dokki-subtopic title='Settings for the highest video quality'>
<p>The following video recorder settings should result in the highest possible output video quality.</p>
<dokki-table headerless>
    <template #table>
        <tr>
            <th>Setting</th>
            <th>Value</th>
        </tr>
        <tr>
            <td>Video codec</td>
            <td>x264</td>
        </tr>
        <tr>
            <td>Profile</td>
            <td>High 4:4:4</td>
        </tr>
        <tr>
            <td>Pixel format</td>
            <td>RGB</td>
        </tr>
        <tr>
            <td>CRF</td>
            <td>0<sup>*</sup></td>
        </tr>
        <tr>
            <td colspan="2">
                <sup>*</sup>Increasing the CRF value to 10&ndash;14 will considerably reduce the size of the resulting video file while maintaining high image quality.
            </td>
        </tr>
    </template>
</dokki-table>
</dokki-subtopic><dokki-subtopic title='Tips for performance'>
<p>If the recorder dialog indicates that frames are being dropped while recording, your system may be limited in CPU or disk performance. Here are a few tips that may help you mitigate those issues.</p>
<p>Since VCS is largely a single-threaded program, dragging or otherwise interacting with its GUI items (e.g. dialog windows) during recording may cause transient frame drops even if your system is otherwise capable.</p>
<p>During recording, frames are saved to disk in batches. If you get a bunch of frames droppede very couple of seconds but are fine otherwise, insufficient disk performance may be the reason. Optimizing the recorder's settings for a smaller file size should help, as would recording at a lower resolution (i.e. with a smaller-sized <a href="#output-window">output window</a>.</p>
<p>If recording fails and you receive an error in the VCS console window to the tune of &quot;x264 [error]: malloc of size ░ failed&quot;, you may be running into a memory fragmentation issue (see <a href="https://github.com/leikareipa/vcs/issues/21">this issue report on GitHub</a>). VCS is a 32-bit program that, while recording video, shares its couple-gigabyte memory space with the x264 encoder, which may result in x264 being unable to allocate a large-enough contiguous block of memory for its own operation. You may be able to fix this issue either by selecting a <em>Preset</em> option closer to &quot;Ultrafast&quot;, reducing the recording resolution (i.e. the size of the output window), or decreasing the size of VCS's pre-allocated memory cache (see the <em>-m</em> <a href="#command-line-options">command-line option</a>).</p>
</dokki-subtopic></dokki-topic><dokki-topic title='Input resolution dialog'>
<p>This dialog can be accessed with <key-combo>Ctrl + I</key-combo> or <menu-path>Context &gt; Capture &gt; Dialogs &gt; Resolution...</menu-path>.</p>
<dokki-warning>
    Not available on Linux.
</dokki-warning>
<p>Normally, the capture device will automatically set the capture resolution to match that of the input signal, but sometimes the result isn't quite right. The input resolution dialog lets you override this resolution with your own one.</p>
<p>You can change a button's assigned resolution by clicking on it while pressing the Alt key.</p>
</dokki-topic><dokki-topic title='Output resolution dialog'>
<p>This dialog can be accessed with <key-combo>Ctrl + O</key-combo> or <menu-path>Context &gt; Output &gt; Dialogs &gt; Resolution...</menu-path>.</p>
<p>The output resolution dialog lets you resize the <a href="#output-window">output window</a>. This also resizes the frames being displayed in the window.</p>
<dokki-subtopic title='Settings explained'>
<dokki-table headerless>
    <template #table>
        <tr>
            <th>Setting</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>Resolution</td>
            <td>
                Lock the size of the output window so that changes to the capture resolution don't affect the output
                resolution. Frames will be scaled up or down as needed to match this resolution.
            </td>
        </tr>
        <tr>
            <td>Relative scale</td>
            <td>
                Scale the size of the output window up or down by a percentage of its base size. The base size is
                either the capture resolution, or, if enabled, the locked output resolution.
            </td>
        </tr>
    </template>
</dokki-table>
</dokki-subtopic></dokki-topic><dokki-topic title='Overlay dialog'>
<p>This dialog can be accessed with <key-combo>Ctrl + L</key-combo> or <menu-path>Context &gt; Output &gt; Dialogs &gt; Overlay...</menu-path>.</p>
<dokki-image src=https://github.com/leikareipa/vcs/raw/master/images/screenshots/v2.3.0/overlay-dialog.png width=878 height=508     ><template #caption>A screenshot of the overlay dialog</template>
                    </dokki-image>
<p>The overlay dialog lets you define a message to be overlaid on the <a href="#output-window">output window</a>.</p>
<p>You can combine normal text with pre-set VCS variables and HTML/CSS formatting to create a message to be shown over the output window.</p>
</dokki-topic><dokki-topic title='Anti-tear dialog'>
<p>This dialog can be accessed with <key-combo>Ctrl + A</key-combo> or <menu-path>Context &gt; Output &gt; Dialogs &gt; Anti-tear...</menu-path>.</p>
<dokki-image src=https://github.com/leikareipa/vcs/raw/master/images/screenshots/v2.4.0/anti-tear-dialog.png width=489 height=502     ><template #caption>A screenshot of the anti-tear dialog</template>
                    </dokki-image>
<p>The anti-tear dialog provides functionality to remove tearing from captured frames.</p>
<p>Under some circumstances, like when the captured source doesn't sync its rendering with the refresh rate, captured frames can contain tearing. VCS's anti-tearer helps mitigate this issue.</p>
<p>Anti-tearing should be considered an experimental feature of VCS. It works well in some cases and not that well in others. It'll completely fail to work if the captured source redraws the screen at a rate higher than the capture's refresh rate – e.g. a game running at 100 FPS with a refresh of 60 Hz.</p>
<dokki-subtopic title='Settings explained'>
<dokki-table headerless>
    <template #table>
        <tr>
            <th>Setting</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>Scan start</td>
            <td>
                Set where the anti-tearer begins scanning each frame for tears. Static screen-wide content like a game's UI bar can prevent the anti-tearing from working, so you should set this value so that such content is excluded. You can choose to visualize the scan range to help you set it up.
            </td>
        </tr>
        <tr>
            <td>Scan end</td>
            <td>
                Same as <strong>Scan start</strong> but for where the scanning should end. This is an offset from the bottom of the screen up, so e.g. a value of 5 at a resolution of 640 &times; 480 would mean the scanning ends at pixel row 475.
            </td>
        </tr>
        <tr>
            <td>Scan direction</td>
            <td>
                If the captured source redraws its screen from bottom to top, set the scan direction to <em>Down</em>. Otherwise, use the <em>Up</em> setting. Using the wrong direction will fully prevent the anti-tearing from working (it may correctly detect tears but won't be able to remove them).
            </td>
        </tr>
        <tr>
            <td>Scan hint</td>
            <td>
                If the captured source redraws its screen at a rate higher than half of its refresh rate but lower than the full refresh rate (e.g. 35 FPS at 60 Hz), you may (or might not) have better results and/or performance by setting this option to <em>Look for one tear per frame</em>. Otherwise, use the <em>Look for multiple tears per frame</em> setting.
            </td>
        </tr>
        <tr>
            <td>Visualization</td>
            <td>
                Draw certain anti-tearing-related markers in the <a href="#output-window">output window</a>.
            </td>
        </tr>
        <tr>
            <td>Threshold</td>
            <td>
                The anti-tearer compares adjacent frames to find which parts of the new frame may be torn (where pixels from the previous frame are still visible). This setting controls the amount by which a pixel's color values are allowed to change between frames without the pixel being considered new (given inherent noise in analog pixels). In an ideal situation where there's no noise in the captured signal, you can set this to 0 or close to it. Otherwise, the value should be high enough to exclude capture noise.
            </td>
        </tr>
        <tr>
            <td>Window size</td>
            <td>
                When scanning frames for tears, the anti-tearer will average together a bunch of horizontal pixels' color values to reduce the negative effect of analog noise. This setting controls the pixel size of the sampling window. Lower values will result in better performance but possibly worse tear detection.
            </td>
        </tr>
        <tr>
            <td>Step size</td>
            <td>
                The number of pixels to skip horizontally when scanning for tears. Higher values will improve performance but may cause a failure to detect subtler tears.
            </td>
        </tr>
        <tr>
            <td>Matches req'd</td>
            <td>
                Set how many times the sampling window must find a pixel's color values to have exceeded the detection threshold for a horizontal row of pixels to be considered new relative to the previous frame. Higher values should reduce the chance of false positives but may also cause a failure to detect subtler tears.
            </td>
        </tr>
    </template>
</dokki-table>
</dokki-subtopic></dokki-topic><dokki-topic title='Filter graph dialog'>
<p>This dialog can be accessed with <key-combo>Ctrl + F</key-combo> or <menu-path>Context &gt; Output &gt; Dialogs &gt; Filter graph...</menu-path>.</p>
<dokki-image src=https://github.com/leikareipa/vcs/raw/master/images/screenshots/v2.4.0/filter-graph-dialog.png width=1187 height=556     ><template #caption>A screenshot of the filter graph dialog</template>
                    </dokki-image>
<p>The filter graph dialog lets you to create chains of image filters to be applied to captured frames prior to display in the <a href="#output-window">output window</a>.</p>
<p>The filter graph is made up of nodes that can be connected together in a chain. These nodes come in three varieties: <em>input gate</em>, <em>output gate</em>, and <em>filter</em>.</p>
<p>The input and output gates determine the resolutions for which the connected filters will be applied. For instance, if you set an input gate's width and height to 640 and 480, and the width and height of an output gate to 1920 and 1080, any filters you connect between these two nodes will be applied when the size of the output window is 1920 × 1080 and the original resolution of the frames (i.e. the capture resolution) is 640 × 480. You can also use the value 0 for a gate's width and/or height to allow VCS to match any value to that dimension: an input gate with a width and height of 0, for instance, will apply the connected filters to frames of all capture resolutions, provided that they also meet the resolution specified for the output gate. A filter graph can have multiple chains of these input-filter-output combos, and VCS will select the most suitable one (or none) given the current capture and output resolutions.</p>
<dokki-tip>
    <p>
        When deciding which of multiple filter chains to use, VCS will prefer more specific chains to more general ones.
    </p>
    <p>
        If you have e.g. an input gate whose width and height are 0, and another input gate whose width and height are 640 and 480, the latter will be used when the capture resolution is exactly 640 &times; 480, and the former otherwise.
    </p>
    <p>
        Likewise, if your input gates are 0 &times; 0 and 640 &times; 0, the former will be applied for capture resolutions of <i>any</i> &times; <i>any</i>, except for 640 &times; <i>any</i>, where the latter chain will apply &ndash; except if you also have a third input gate of 640 &times; 480, in which case that will be used when the capture resolution is exactly 640 &times; 480.
    </p>
</dokki-tip>
<p>To connect two nodes, click and drag with the left mouse button from one node's output edge (square) to another's input edge (circle), or vice versa. A node can be connected to as many other nodes as you like. To disconnect a node from another, right-click on the node's output edge, and select the other node from the list that pops up. To remove a node itself from the graph, right-click on the node and select to remove it. To add nodes to the graph, right-click on the graph's background to bring up the node menu, or select <menu-path>Filters</menu-path> from the dialog's menu bar.</p>
</dokki-topic><dokki-topic title='Mouse controls'>
<dokki-table headerless>
    <template #table>
        <tr>
            <th>Action</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>Double-click <a href="#output-window">output window</a></td>
            <td>Toggle the window border on/off.</td>
        </tr>
        <tr>
            <td>Middle-click output window</td>
            <td>Magnify the portion of the output window over which the cursor is hovering.</td>
        </tr>
        <tr>
            <td>Left-click and drag output window</td>
            <td>Move the window (same as dragging by its title bar).</td>
        </tr>
        <tr>
            <td>Right-click output window</td>
            <td>Open the output window's <a href="#output-window-context-menu">context menu</a>.</td>
        </tr>
        <tr>
            <td>Mouse wheel over output window</td>
            <td>Scale the output window up/down.</td>
        </tr>
    </template>
</dokki-table>
</dokki-topic><dokki-topic title='Keyboard controls'>
<dokki-table headerless>
    <template #table>
        <tr>
            <th>Key(s)</th>
            <th>Description</th>
        </tr>
        <tr>
            <td><key-combo>F11</key-combo></td>
            <td>Toggle fullscreen mode on/off.</td>
        </tr>
        <tr>
            <td><key-combo>Ctrl + A</key-combo></td>
            <td>Open the anti-tear dialog.</td>
        </tr>
        <tr>
            <td><key-combo>Ctrl + F</key-combo></td>
            <td>Open the filter graph dialog.</td>
        </tr>
        <tr>
            <td><key-combo>Ctrl + V</key-combo></td>
            <td>Open the video settings dialog.</td>
        </tr>
        <tr>
            <td><key-combo>Ctrl + I</key-combo></td>
            <td>Open the input resolution dialog.</td>
        </tr>
        <tr>
            <td><key-combo>Ctrl + O</key-combo></td>
            <td>Open the output resolution dialog.</td>
        </tr>
        <tr>
            <td><key-combo>Ctrl + R</key-combo></td>
            <td>Open the record dialog.</td>
        </tr>
        <tr>
            <td><key-combo>Ctrl + L</key-combo></td>
            <td>Open the overlay dialog.</td>
        </tr>
        <tr>
            <td><key-combo>Ctrl + Shift + key</key-combo></td>
            <td>Toggle the corresponding dialog's functionality on/off (e.g.
                <key-combo>Ctrl + Shift + R</key-combo> for recording).</td>
        </tr>
        <tr>
            <td><key-combo>Ctrl + 1&hellip;9</key-combo></td>
            <td>Shortcuts for the input resolution buttons on the control panel's Input tab.</td>
        </tr>
        <tr>
            <td><key-combo>Shift + 1&hellip;2</key-combo></td>
            <td>Set the input channel index.</td>
        </tr>
    </template>
</dokki-table>
</dokki-topic><dokki-topic title='Command-line options'>
<dokki-table headerless>
    <template #table>
        <tr>
            <th>Option</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>-i <i>&lt;input channel&gt;</i></td>
            <td>
                Start capture on the given input channel (1&#8230;<i>n</i>). On Linux, a value of 1 corresponds to <em>/dev/video0</em>, 2 to <em>/dev/video1</em>, 3 to <em>/dev/video2</em>, and so on. By default, channel 1 will be used.
            </td>
        </tr>
        <tr>
            <td>-v <i>&lt;path&gt;</i></td>
            <td>
                Load video presets from the given file on start-up. Video preset files typically have the .vcs-video suffix.
            </td>
        </tr>
        <tr>
            <td>-f <i>&lt;path&gt;</i></td>
            <td>
                Load a custom filter graph from the given file on start-up. Filter graph files typically have the .vcs-filter-graph suffix.
            </td>
        </tr>
        <tr>
            <td>-a <i>&lt;path&gt;</i></td>
            <td>
                Load alias resolutions from the given file on start-up. Alias resolution files typically have the .vcs-alias suffix.
            </td>
        </tr>
        <tr>
            <td>-m <i>&lt;value in MB&gt;</i></td>
            <td>
                Set the amount of system memory that VCS reserves on startup. If you're getting error messages about the memory cache running out, increase this value. If you get x264 allocation errors when attempting to record video, try reducing this value. Default: 256 MB.
            </td>
        </tr>
    </template>
</dokki-table>
</dokki-topic>
                </dokki-topics>
            </template>
        </body></html>
